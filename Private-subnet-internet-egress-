@@ -18,13 +18,20 @@ aws-infra/modules/network/
├── variables.tf
├── versions.tf
├── vpc.tf
├── test/                   # Terratest skeleton for automated testing
│   └──  network_test.go
├── test/                   # Terratest automated tests
│   ├── helpers.go
│   ├── network_test.go
│   └── private_egress_test.go
└── examples/               # Usage examples and module testing
    └── basic_usage/
    ├── basic_usage/
    │   ├── main.tf
    │   ├── outputs.tf
    │   └── versions.tf
    └── private_egress_via_edge/
        ├── main.tf
        ├── outputs.tf
        └── versions.tf
```

- `vpc.tf`: Defines the main Virtual Private Cloud (VPC) resource, including its CIDR block and tags. This is the foundational network component for all other resources.
@@ -35,8 +42,8 @@ aws-infra/modules/network/
- `variables.tf`: Declares all input variables required by the module, such as CIDR blocks, subnet counts, and tags. Customize these to fit your environment.
- `outputs.tf`: Exposes key resource attributes (e.g., VPC ID, subnet IDs, security group IDs) for use by parent modules or other resources.
- `versions.tf`: Specifies the required Terraform and provider versions to ensure compatibility and reproducibility.
- `test/`: Contains a Terratest skeleton for automated testing of the module.
- `examples/basic_usage`: Provides a working example of how to consume this module. You can use it as both a reference for usage and as a way to validate the module with terraform plan/apply.
- `test/`: Terratest automated tests for infrastructure and network validation.
- `examples/`: Runnable configurations demonstrating module usage. You can use it as both a reference for usage and as a way to validate the module with terraform plan/apply.


## Usage
@@ -67,6 +74,7 @@ module "network" {
}
```


## Examples Directory

The `examples/` folder contains runnable configurations that demonstrate how to use this module.
@@ -80,36 +88,72 @@ The `examples/` folder contains runnable configurations that demonstrate how to
  - **Documentation**, showing expected inputs and outputs.  
- You can copy and adapt this configuration as a starting point for your own infrastructure.

### `private_egress_via_edge/`

- An **advanced example** demonstrating cost-effective private subnet internet egress.
- Replaces NAT Gateway with a NAT instance (Edge VM) for significant cost savings.
- Implements the complete architecture:
  - Edge instance with `source_dest_check = false`
  - iptables MASQUERADE rules for the entire VPC CIDR
  - Private route table with default route (0.0.0.0/0) pointing to Edge instance
  - Automated SSH key generation for testing
- Includes comprehensive Terratest that validates:
  - Route table configuration
  - Instance connectivity
  - Private instance internet access via Edge instance

## Testing

### Manual Testing with Examples
### Prerequisites

The `examples/basic_usage/` directory serves as the primary test harness:
- Go installed (v1.20+ recommended)
- go mod initialized in test/ folder
- SSH private key output from Terraform accessible

### Manual Testing with Examples

#### Basic Validation
```bash
cd examples/basic_usage/
terraform init
terraform validate  # Should pass with zero errors
terraform plan      # Should show only network resources
```

### Terratest Skeleton
#### NAT Instance Validation
```bash
cd examples/private_egress_via_edge/
terraform init
terraform validate  # Should pass with zero errors
terraform plan      # Should show network resources + NAT instances
```

A basic Terratest skeleton is provided in the `test/` directory for automated testing:
### Automated Testing with Terratest

#### Basic Infrastructure Tests
```bash
cd test/
go mod init network_test
go mod tidy
go test -v -timeout 30m -run TestNetworkModule .
```

#### NAT Functionality Tests
```bash
cd test/
go mod init network-test
go mod init private_egress_test
go mod tidy
go test -v -timeout 30m .
go test -v -timeout 30m -run TestPrivateEgressHTTPS .
```

The Terratest skeleton currently validates:
- VPC creation
- Correct subnet count (1 public, 1 private)
- Security group existence
- Basic structure for future tag validation
The Terratest suite validates:
- **Basic Structure**: VPC creation, subnet counts, security groups existence
- **NAT Functionality**: 
  - Edge instance source/dest check configuration
  - Private route table default route to Edge instance
  - Actual internet access from private instances via SSH testing

**Note**: This is currently a skeleton focused on Terraform output validation. Future enhancements could include AWS API calls for comprehensive resource validation.
**Note**: The NAT test requires SSH connectivity and validates real network traffic flow from private instances to the internet.
```
 You can copy and adapt this configuration as a starting point for your own infrastructure.
 188 changes: 188 additions & 0 deletions188  
aws-infra/modules/network/examples/private_egress_via_edge/main.tf
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,188 @@
# =============================================================================
# examples/private_egress_via_edge/main.tf
# Test configuration for private egress via Edge NAT instance
# =============================================================================

# Provider config without a specific profile to use default auth chain
provider "aws" {
  region = "eu-central-1"
}

# Get available AZs in the region
data "aws_availability_zones" "available" {
  state = "available"
}

# Locals for consistent values and dynamic AMI selection
locals {
  instance_type       = "t3.micro"
  vpc_cidr            = "10.0.0.0/16"
  allowed_admin_cidrs = ["0.0.0.0/0"]
  project_name        = "layered-infra"
  # Define common_tags in one place
  common_tags = {
    Project     = "layered-infra"
    ManagedBy   = "Terraform"
    Environment = "Testing"
    Team        = "A"
    Module      = "Private-Egress-via-Edge-Test"
  }

  # Detect architecture from instance type
  arch            = can(regex(".*g\\.", local.instance_type)) ? "arm64" : "amd64"
  ubuntu_version  = "22.04"
  ubuntu_ssm_path = "/aws/service/canonical/ubuntu/server/${local.ubuntu_version}/stable/current/${local.arch}/hvm/ebs-gp2/ami-id"
}

# Generate SSH key pair inside Terraform
resource "tls_private_key" "test_key" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

resource "aws_key_pair" "this" {
  key_name   = "${local.project_name}-nat-test-key"
  public_key = tls_private_key.test_key.public_key_openssh
}

# Save private key locally for Terratest
resource "local_file" "ssh_private_key" {
  content         = tls_private_key.test_key.private_key_pem
  filename        = abspath("${path.module}/network_test_key.pem")
  file_permission = "0600"
}

module "network" {
  source = "../.." # Points to the root network module directory

  project_name = local.project_name
  common_tags  = local.common_tags


  vpc_cidr            = local.vpc_cidr
  allowed_admin_cidrs = local.allowed_admin_cidrs

  # Single AZ configuration
  az_configurations = {
    (data.aws_availability_zones.available.names[0]) = {
      public_subnet_cidr  = "10.0.1.0/24"
      private_subnet_cidr = "10.0.2.0/24"
    }
  }

  # Set other variables with their defaults for clarity
  enable_dns_support            = true
  enable_dns_hostnames          = true
  allow_map_public_ip_on_launch = true
  application_port              = 3000
  open_internet_cidr            = "0.0.0.0/0"
  tcp_protocol                  = "tcp"
  udp_protocol                  = "udp"
  all_protocols                 = "-1"
  https_port                    = 443
  http_port                     = 80
  ssh_port                      = 22
  wireguard_port                = 51820
}

data "aws_ssm_parameter" "ubuntu" {
  name = local.ubuntu_ssm_path
}

# --- Create the Edge Instance that will act as NAT ---
resource "aws_instance" "test_edge_instance" {
  ami           = data.aws_ssm_parameter.ubuntu.value
  instance_type = local.instance_type
  subnet_id     = module.network.public_subnet_ids[0]

  # CRITICAL: Disable source/dest check for NAT functionality
  source_dest_check = false

  # Security group that allows SSH for setup
  vpc_security_group_ids = [module.network.sg_edge_id]

  # SSH key for access
  key_name = aws_key_pair.this.key_name

  #Cloud-init script embedded directly
  user_data = <<-EOT
#!/bin/bash
set -euxo pipefail
exec > >(tee /var/log/edge-init.log|logger -t user-data ) 2>&1
echo "[edge-init] Start user_data script"
# Enable IP forwarding
sysctl -w net.ipv4.ip_forward=1
echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
    # Install required packages
    export DEBIAN_FRONTEND=noninteractive
    apt-get update -y
    apt-get install -y iptables-persistent curl
# Detect primary interface
PRIMARY_IFACE=$(ip route show default | awk '{print $5}' | head -n1)
echo "[edge-init] Primary interface: $PRIMARY_IFACE"
# Create persistent NAT rules file
cat > /etc/iptables/rules.v4 <<EOF
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s ${local.vpc_cidr} -o $PRIMARY_IFACE -j MASQUERADE
COMMIT
EOF
# Load rules immediately
iptables-restore < /etc/iptables/rules.v4
  echo "[edge-init] Final NAT table:" | tee -a /var/log/edge-init.log
  iptables -t nat -S | tee -a /var/log/edge-init.log
  echo "[edge-init] Completed successfully" | tee -a /var/log/edge-init.log
EOT

  tags = merge(local.common_tags, {
    Name = "${local.project_name}-test-edge-instance"
  })

}

# --- Create a test instance in private subnet to validate NAT ---
resource "aws_instance" "test_appdb_instance" {
  ami           = data.aws_ssm_parameter.ubuntu.value
  instance_type = local.instance_type
  subnet_id     = module.network.private_subnet_ids[0]

  # Security group that allows outbound traffic
  vpc_security_group_ids = [module.network.sg_app_id]

  # SSH key for access
  key_name = aws_key_pair.this.key_name

  tags = merge(local.common_tags, {
    Name = "${local.project_name}-test-appdb-instance"
  })

}

# --- Create route in private route table to Edge NAT instance ---
resource "aws_route" "private_to_nat" {
  route_table_id         = module.network.private_route_table_id
  destination_cidr_block = "0.0.0.0/0"
  network_interface_id   = aws_instance.test_edge_instance.primary_network_interface_id
}

# Allow SSH from Edge SG for testing over ssh
resource "aws_vpc_security_group_ingress_rule" "app_ssh_from_edge" {
  security_group_id            = module.network.sg_app_id
  description                  = "Allow SSH from Edge SG"
  ip_protocol                  = "tcp"
  from_port                    = 22
  to_port                      = 22
  referenced_security_group_id = module.network.sg_edge_id
}
 43 changes: 43 additions & 0 deletions43  
aws-infra/modules/network/examples/private_egress_via_edge/outputs.tf
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,43 @@
# =============================================================================
# examples/private_egress_via_edge/outputs.tf
# Outputs for NAT instance testing
# =============================================================================

output "edge_instance_id" {
  value = aws_instance.test_edge_instance.id
}

output "edge_public_ip" {
  value = aws_instance.test_edge_instance.public_ip
}

output "edge_primary_network_interface_id" {
  value = aws_instance.test_edge_instance.primary_network_interface_id
}

output "private_test_instance_id" {
  value = aws_instance.test_appdb_instance.id
}

output "private_test_private_ip" {
  value = aws_instance.test_appdb_instance.private_ip
}

# Optional but helpful
output "private_route_table_id" {
  value = module.network.private_route_table_id
}

output "vpc_cidr" {
  value = local.vpc_cidr
}

output "ssh_private_key_file" {
  value       = abspath("${path.module}/network_test_key.pem")
  description = "Path to the generated private key for SSH access to test instances"
}

output "ssh_key_name" {
  value       = aws_key_pair.this.key_name
  description = "Name of the generated AWS Key Pair"
}
 20 changes: 20 additions & 0 deletions20  
aws-infra/modules/network/examples/private_egress_via_edge/versions.tf
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,20 @@
# This file is necessary for running 'terraform init' and 'terraform validate'
# in the examples/private_egress_via_edge/ directory.
terraform {
  required_version = "~> 1.12.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.5.0"
    }
    local = {
      source  = "hashicorp/local"
      version = ">= 2.0"
    }
    tls = {
      source  = "hashicorp/tls"
      version = "~> 4.0" # Add TLS provider requirement
    }
  }
}
 198 changes: 198 additions & 0 deletions198  
aws-infra/modules/network/test/helpers.go
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,198 @@
package test

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	gossh "golang.org/x/crypto/ssh"
	"github.com/gruntwork-io/terratest/modules/retry"
	"github.com/stretchr/testify/require"
)

const cmdPreviewLen = 140

// --- small helpers -----------------------------------------------------------

func trimForLog(s string, n int) string {
	if len(s) <= n {
		return strings.TrimSpace(s)
	}
	return strings.TrimSpace(s[:n]) + "…"
}

// ResolveKeyPath ensures we use an absolute path for the private key
func ResolveKeyPath(t *testing.T, keyPath string) string {
	t.Helper()

	absKeyFile, err := filepath.Abs(keyPath)
	require.NoError(t, err, "cannot resolve absolute path to private key")

	info, err := os.Stat(absKeyFile)
	require.NoError(t, err, "private key file does not exist")

	t.Logf("🔐 Using SSH key: %s (size=%d bytes, mode=%s)", absKeyFile, info.Size(), info.Mode())
	return absKeyFile
}

// --- direct SSH --------------------------------------------------------------

/*
RunSSHCommand runs `cmd` on host using username and private key file,
returning combined stdout+stderr.
*/
func RunSSHCommand(t *testing.T, hostname, username, privateKeyFile, cmd string) (string, error) {
	t.Helper()

	t.Logf("➡️  SSH connect %s@%s:22", username, hostname)

	keyBytes, err := os.ReadFile(privateKeyFile)
	require.NoError(t, err, "failed to read private key file")

	signer, err := gossh.ParsePrivateKey(keyBytes)
	require.NoError(t, err, "failed to parse private key")

	config := &gossh.ClientConfig{
		User:            username,
		Auth:            []gossh.AuthMethod{gossh.PublicKeys(signer)},
		HostKeyCallback: gossh.InsecureIgnoreHostKey(),
		Timeout:         30 * time.Second,
	}

	client, err := gossh.Dial("tcp", fmt.Sprintf("%s:22", hostname), config)
	require.NoError(t, err, "failed to dial SSH")
	defer client.Close()
	t.Logf("✅ SSH connected to %s", hostname)

	session, err := client.NewSession()
	require.NoError(t, err, "failed to create SSH session")
	defer session.Close()

	t.Logf("🖥️  Running on %s: %q", hostname, trimForLog(cmd, cmdPreviewLen))

	var combined strings.Builder
	session.Stdout = &combined
	session.Stderr = &combined

	err = session.Run(cmd)
	out := combined.String()

	if err != nil {
		t.Logf("❌ Command failed on %s: %v", hostname, err)
		t.Logf("⤵️  Output (preview): %s", trimForLog(out, 400))
	} else {
		t.Logf("✅ Command succeeded on %s", hostname)
		t.Logf("⤵️  Output (preview): %s", trimForLog(out, 400))
	}

	return out, err
}

// RetrySSHCommand wraps RunSSHCommand with retries and descriptive logging
func RetrySSHCommand(t *testing.T, hostname, username, privateKeyFile, cmd string) (string, error) {
	t.Helper()
	desc := fmt.Sprintf("ssh->%s run: %s", hostname, trimForLog(cmd, cmdPreviewLen))
	t.Logf("🔁 %s (with retries)", desc)

	return retry.DoWithRetryE(t, desc, 15, 10*time.Second, func() (string, error) {
		return RunSSHCommand(t, hostname, username, privateKeyFile, cmd)
	})
}

// --- SSH via edge (tunneled) -------------------------------------------------

/*
RunSSHViaEdge runs a command on a private instance through the edge (jump host),
without requiring ProxyJump support on the local machine.
*/
func RunSSHViaEdge(t *testing.T, edgeHost, privateHost, username, keyFile, cmd string) (string, error) {
	t.Helper()

	t.Logf("➡️  SSH (edge) connect %s@%s:22", username, edgeHost)

	keyBytes, err := os.ReadFile(keyFile)
	require.NoError(t, err, "failed to read private key file")

	signer, err := gossh.ParsePrivateKey(keyBytes)
	require.NoError(t, err, "failed to parse private key")

	edgeConfig := &gossh.ClientConfig{
		User:            username,
		Auth:            []gossh.AuthMethod{gossh.PublicKeys(signer)},
		HostKeyCallback: gossh.InsecureIgnoreHostKey(),
		Timeout:         30 * time.Second,
	}

	// Connect to edge instance
	edgeClient, err := gossh.Dial("tcp", fmt.Sprintf("%s:22", edgeHost), edgeConfig)
	require.NoError(t, err, "failed to dial edge SSH")
	defer edgeClient.Close()
	t.Logf("✅ SSH connected to edge %s", edgeHost)

	// Dial TCP from edge to private instance
	t.Logf("🔌 Tunneling TCP from edge -> %s:22", privateHost)
	conn, err := edgeClient.Dial("tcp", fmt.Sprintf("%s:22", privateHost))
	require.NoError(t, err, "failed to dial private host from edge")

	// Create a new SSH client over the connection to the private instance
	t.Logf("🔐 Establishing SSH client over tunnel to %s", privateHost)
	ncc, chans, reqs, err := gossh.NewClientConn(conn, privateHost+":22", edgeConfig)
	require.NoError(t, err, "failed to create tunneled SSH client connection")
	privateClient := gossh.NewClient(ncc, chans, reqs)
	defer privateClient.Close()
	t.Logf("✅ SSH tunneled client ready for %s", privateHost)

	// Open session on private instance
	session, err := privateClient.NewSession()
	require.NoError(t, err, "failed to create session on private host")
	defer session.Close()

	t.Logf("🖥️  Running on %s via %s: %q", privateHost, edgeHost, trimForLog(cmd, cmdPreviewLen))

	var combined strings.Builder
	session.Stdout = &combined
	session.Stderr = &combined

	err = session.Run(cmd)
	out := combined.String()

	if err != nil {
		t.Logf("❌ Command failed on %s via %s: %v", privateHost, edgeHost, err)
		t.Logf("⤵️  Output (preview): %s", trimForLog(out, 400))
	} else {
		t.Logf("✅ Command succeeded on %s via %s", privateHost, edgeHost)
		t.Logf("⤵️  Output (preview): %s", trimForLog(out, 400))
	}

	return out, err
}

// RetrySSHViaEdge wraps RunSSHViaEdge with retries and descriptive logging
func RetrySSHViaEdge(t *testing.T, edgeHost, privateHost, username, keyFile, cmd string) (string, error) {
	t.Helper()
	desc := fmt.Sprintf("ssh->%s->%s run: %s", edgeHost, privateHost, trimForLog(cmd, cmdPreviewLen))
	t.Logf("🔁 %s (with retries)", desc)

	return retry.DoWithRetryE(t, desc, 20, 30*time.Second, func() (string, error) {
		return RunSSHViaEdge(t, edgeHost, privateHost, username, keyFile, cmd)
	})
}

// GetMyPublicIP returns the public IP of the machine running the tests
func GetMyPublicIP(t *testing.T) string {
	t.Helper()
	resp, err := http.Get("https://checkip.amazonaws.com")
	require.NoError(t, err, "failed to reach checkip service")
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err, "failed to read checkip response")
	ip := strings.TrimSpace(string(body))
	t.Logf("🌍 Detected local public IP: %s", ip)
	return ip
}

 50 changes: 50 additions & 0 deletions50  
aws-infra/modules/network/test/private_egress_test.go
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,50 @@
package test

import (
	"testing"

	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/require"
)

// TestPrivateEgressHTTPS validates that the private instance
// can reach the public internet via the Edge NAT instance.
func TestPrivateEgressHTTPS(t *testing.T) {
	t.Parallel()

	terraformDir := "../examples/private_egress_via_edge"
	tfOpts := &terraform.Options{
		TerraformDir: terraformDir,
	}

	t.Log("🚀 Starting Terraform apply for private egress test...")
	defer func() {
		t.Log("🧹 Destroying Terraform resources...")
		terraform.Destroy(t, tfOpts)
		t.Log("✅ Terraform destroy complete.")
	}()

	terraform.InitAndApply(t, tfOpts)
	t.Log("✅ Terraform apply complete, infrastructure provisioned.")

	// Collect outputs
	t.Log("📦 Collecting Terraform outputs...")
	edgeIP := terraform.Output(t, tfOpts, "edge_public_ip")
	privateIP := terraform.Output(t, tfOpts, "private_test_private_ip")
	keyFile := ResolveKeyPath(t, terraform.Output(t, tfOpts, "ssh_private_key_file"))
	t.Logf("🌐 Edge public IP: %s | 🔒 Private IP: %s | 🔑 Key: %s", edgeIP, privateIP, keyFile)

	// Command to run on private instance
	cmd := "curl -sI https://api.github.com | head -n 1"
	t.Logf("🖥️  Test command to run on private instance: %q", cmd)

	// Use helpers.go with retry + edge tunnel
	t.Log("🔁 Executing curl from private instance via Edge tunnel...")
	out, err := RetrySSHViaEdge(t, edgeIP, privateIP, "ubuntu", keyFile, cmd)

	require.NoError(t, err, "SSH command via edge host failed")
	require.Contains(t, out, "200", "expected HTTP 200 from https://api.github.com")

	t.Logf("🎉 SUCCESS: Private instance %s reached internet via Edge %s (got response: %q)", privateIP, edgeIP, out)
}
